// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1024.Stronghold;


import edu.wpi.first.wpilibj.AnalogGyro;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.AnalogPotentiometer;
import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DigitalOutput;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.I2C;
import edu.wpi.first.wpilibj.I2C.Port;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.Relay;
import edu.wpi.first.wpilibj.Relay.Direction;
import edu.wpi.first.wpilibj.SerialPort;
import edu.wpi.first.wpilibj.Solenoid;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static Solenoid drivetrainShifter;
    public static CANTalon drivetrainFrontLeft;
    public static CANTalon drivetrainFrontRight;
    public static CANTalon drivetrainBackLeft;
    public static CANTalon drivetrainBackRight;
    public static CANTalon drivetrainMidLeft;
    public static CANTalon drivetrainMidRight;
    public static Encoder drivetrainLeftEncoder;
    public static Encoder drivetrainRightEncoder;
    public static AnalogGyro drivetrainGyro;
    public static DoubleSolenoid defenseBusterArm;
    public static DigitalInput defenseBusterArmUp;
    public static DigitalInput defenseBusterArmDown;
    public static AnalogPotentiometer defenseBusterArmPosition;
    public static CANTalon intakeLeftMotor;
    public static CANTalon intakeRightMotor;
    public static DoubleSolenoid intakeArm;
    public static Solenoid launcherOne;
    public static Solenoid launcherTwo;
    /*public static Solenoid launcherThree;
    public static Solenoid launcherFour;
    */
    public static Solenoid launcherPressureAdjust;
    public static Compressor compressorCompressor;
    public static I2C pixyi2c;
    public static DigitalOutput pixyPower;
    public static Relay photonCannonPower;
    //public static AHRS navx;
    //public static AnalogInput servoIn;
    //public static REVDigitBoard autoChooser;


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public static void init() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        drivetrainShifter = new Solenoid(0, 4);
        LiveWindow.addActuator("Drivetrain", "Shifter", drivetrainShifter);
        
        drivetrainFrontLeft = new CANTalon(0);
        LiveWindow.addActuator("Drivetrain", "FrontLeft", drivetrainFrontLeft);
        
        drivetrainFrontRight = new CANTalon(1);
        LiveWindow.addActuator("Drivetrain", "FrontRight", drivetrainFrontRight);
        
        drivetrainBackLeft = new CANTalon(2);
        LiveWindow.addActuator("Drivetrain", "BackLeft", drivetrainBackLeft);
        
        drivetrainBackRight = new CANTalon(3);
        LiveWindow.addActuator("Drivetrain", "BackRight", drivetrainBackRight);
        
        drivetrainLeftEncoder = new Encoder(0, 1, false, EncodingType.k4X);
        LiveWindow.addSensor("Drivetrain", "LeftEncoder", drivetrainLeftEncoder);
        drivetrainLeftEncoder.setDistancePerPulse(1.0);
        drivetrainLeftEncoder.setPIDSourceType(PIDSourceType.kRate);
        drivetrainRightEncoder = new Encoder(2, 3, false, EncodingType.k4X);
        LiveWindow.addSensor("Drivetrain", "RightEncoder", drivetrainRightEncoder);
        drivetrainRightEncoder.setDistancePerPulse(1.0);
        drivetrainRightEncoder.setPIDSourceType(PIDSourceType.kRate);
        drivetrainGyro = new AnalogGyro(1);
        defenseBusterArm = new DoubleSolenoid(0, 0, 1);
        LiveWindow.addActuator("DefenseBuster", "Arm", defenseBusterArm);
        defenseBusterArmUp = new DigitalInput(4);
        LiveWindow.addSensor("DefenseBuster", "ArmUp", defenseBusterArmUp);
        
        defenseBusterArmDown = new DigitalInput(5);
        LiveWindow.addSensor("DefenseBuster", "ArmDown", defenseBusterArmDown);
        
        defenseBusterArmPosition = new AnalogPotentiometer(0, 1.0, 0.0);
        LiveWindow.addSensor("DefenseBuster", "ArmPosition", defenseBusterArmPosition);
        
        intakeLeftMotor = new CANTalon(6);
        LiveWindow.addActuator("Intake", "LeftMotor", intakeLeftMotor);
        
        intakeRightMotor = new CANTalon(7);
        LiveWindow.addActuator("Intake", "RightMotor", intakeRightMotor);
        
        intakeArm = new DoubleSolenoid(0, 2, 3);
        LiveWindow.addActuator("Intake", "Arm", intakeArm);
        
        launcherOne = new Solenoid(0, 5);
        LiveWindow.addActuator("Launcher", "One", launcherOne);
        
        launcherTwo = new Solenoid(0, 6);
        LiveWindow.addActuator("Launcher", "Two", launcherTwo);
        
//        launcherThree = new Solenoid(0, 7);
//        LiveWindow.addActuator("Launcher", "Three", launcherThree);
        
        /*launcherFour = new Solenoid(1, 0);
        LiveWindow.addActuator("Launcher", "Four", launcherFour);
        */
        /*launcherPressureAdjust = new Solenoid(1, 1);
        LiveWindow.addActuator("Launcher", "PressureAdjust", launcherPressureAdjust); */
        /*
        scalerRightWinch = new CANTalon(8);
        LiveWindow.addActuator("Scaler", "RightWinch", scalerRightWinch);
        
        scalerLeftWinch = new CANTalon(9);
        LiveWindow.addActuator("Scaler", "LeftWinch", scalerLeftWinch);
        
        scalerReleaser = new Servo(7);
        LiveWindow.addActuator("Scaler", "Releaser", scalerReleaser);
        
        scalerHookLauncher = new Solenoid(0, 7);
        LiveWindow.addActuator("Scaler", "HookLauncher", scalerHookLauncher);
        */
        compressorCompressor = new Compressor(0);
        
        pixyi2c = new I2C(Port.kOnboard, 0x54);
        pixyPower = new DigitalOutput(6);
        photonCannonPower = new Relay(1);
        
        LiveWindow.addActuator("SPIKE",  "photonCannon", photonCannonPower);
        
        //navx = new AHRS(SerialPort.Port.kUSB);
        //LiveWindow.addActuator("NAVX", "NAVX", navx);
        //autoChooser = new REVDigitBoard();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    }
}
