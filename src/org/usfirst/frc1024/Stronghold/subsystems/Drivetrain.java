// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc1024.Stronghold.subsystems;

import org.usfirst.frc1024.Stronghold.Robot;
import org.usfirst.frc1024.Stronghold.RobotMap;
import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.command.Subsystem;

/**
 *
 */
public class Drivetrain extends Subsystem {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final Solenoid shifter = RobotMap.drivetrainShifter;
	private final static CANTalon frontLeft = RobotMap.drivetrainFrontLeft;
	private final static CANTalon frontRight = RobotMap.drivetrainFrontRight;
	private final static CANTalon backLeft = RobotMap.drivetrainBackLeft;
	private final static CANTalon backRight = RobotMap.drivetrainBackRight;
	public final Encoder leftEncoder = RobotMap.drivetrainLeftEncoder;
	public final Encoder rightEncoder = RobotMap.drivetrainRightEncoder;
	public final AnalogGyro gyro = RobotMap.drivetrainGyro;
	
	final double voltsPerDegreePerSecond = .0128; 
	double angleSetpoint = 0.0;
    double pGain = .006;

    		
    double turningValue; 

	// Direction the robot is facing at start
	public static String direction = "up";
	double speed = 1;

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
		//setDefaultCommand(new Drive());
	}

	public void shiftDown() {
		shifter.set(true);
	}

	public void shiftUp() {
		shifter.set(false);
	}
	public void driveMotors(double lSpeed, double rSpeed) {
		frontLeft.set(-lSpeed);
		backLeft.set(-lSpeed);
		frontRight.set(rSpeed);
		backRight.set(rSpeed);
	}
	
	public void driveInches(double distance, double speed){
		Robot.drivetrain.leftEncoder.reset();
		Robot.drivetrain.rightEncoder.reset();
		driveMotors(speed, speed);
		if(distance > 0){
			while (((((Robot.drivetrain.leftEncoder.getDistance() + Robot.drivetrain.rightEncoder.getDistance()) / 2)
					/ 250) * (6 * Math.PI)) <= distance){
			}
		}
		if(distance < 0){
			while (((((Robot.drivetrain.leftEncoder.getDistance() + Robot.drivetrain.rightEncoder.getDistance()) / 2)
					/ 250) * (6 * Math.PI)) >= distance){
			}
		}
		driveMotors(0, 0);
	}
	
	public void driveStraightInches(double distance, double speed){
		Robot.drivetrain.leftEncoder.reset();
		Robot.drivetrain.rightEncoder.reset();
		if(distance > 0){
			while (((((Robot.drivetrain.leftEncoder.getDistance() + Robot.drivetrain.rightEncoder.getDistance()) / 2)
					/ 250) * (6 * Math.PI)) <= distance){
				driveMotors(speed - gyro.getAngle() / 10, speed + gyro.getAngle() / 10);
			}
		}
		if(distance < 0){
			while (((((Robot.drivetrain.leftEncoder.getDistance() + Robot.drivetrain.rightEncoder.getDistance()) / 2)
					/ 250) * (6 * Math.PI)) >= distance){
				driveMotors(speed - gyro.getAngle() / 10, speed + gyro.getAngle() / 10);
			}
		}
		driveMotors(0, 0);
	}
}